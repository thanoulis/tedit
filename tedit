#!/usr/bin/env wish

package require Tk

################################################################################
# SCRATCHPAD
#
namespace eval Scratchpad {
    variable show       false
    variable count      0
    variable notebook   {}
    variable menu       {}
}

proc createScratchpadMenu {w} {
    menu [set Scratchpad::menu $w.popup_menu] -tearoff 0
        $Scratchpad::menu add command -label "New Tab" \
            -underline 0 -accelerator "Control+T" \
            -command {newScratchpadTab $Scratchpad::notebook $Scratchpad::count}
        $Scratchpad::menu add command -label "Close Tab" \
            -underline 1  -accelerator "Control+F4" -state disabled \
            -command {closeScratchpadTab $Scratchpad::notebook}
        $Scratchpad::menu add separator
        $Scratchpad::menu add command -label "Cut" \
            -underline 2 -accelerator "Control+X" \
            -command {event generate [focus] <<Cut>>}
        $Scratchpad::menu add command -label "Copy" \
            -underline 0 -accelerator "Control+C" \
            -command {event generate [focus] <<Copy>>}
        $Scratchpad::menu add command -label "Paste" \
            -underline 0 -accelerator "Control+V" \
            -command {event generate [focus] <<Paste>>}
        $Scratchpad::menu add separator
        $Scratchpad::menu add command -label "Hide Scratchpad" \
            -underline 0 -accelerator "F8" \
            -command {.m.show invoke "Scratchpad"}
}

proc newScratchpadTab {w count} {
    ttk::frame [set scratchpadTab(frame) $w.f$count]
    set scratchpadTab(text) $w.text$count
    set scratchpadTab(yscroll) $w.yscroll$count
    set scratchpadTab(xscroll) $w.xscroll$count

    tk::text $scratchpadTab(text) -wrap none -highlightthickness 0 \
        -yscrollcommand [list $scratchpadTab(yscroll) set] \
        -xscrollcommand [list $scratchpadTab(xscroll) set]

    ttk::scrollbar $scratchpadTab(yscroll) \
        -orient vertical -command [list $scratchpadTab(text) yview]
    ttk::scrollbar $scratchpadTab(xscroll) \
        -orient horizontal -command [list $scratchpadTab(text) xview]

    grid $scratchpadTab(text)    -in $scratchpadTab(frame) -row 0 -column 0 -sticky news
    grid $scratchpadTab(yscroll) -in $scratchpadTab(frame) -row 0 -column 1 -sticky ns
    grid $scratchpadTab(xscroll) -in $scratchpadTab(frame) -row 1 -column 0 -sticky we

    grid rowconfigure    $scratchpadTab(frame) $scratchpadTab(text) -weight 1
    grid columnconfigure $scratchpadTab(frame) $scratchpadTab(text) -weight 1

    $w add $scratchpadTab(frame) -text "Scratch $count" -underline 8
    focus $scratchpadTab(text)
    incr Scratchpad::count

    if {[$w index end] > 1} {
        $Scratchpad::menu entryconfigure "Close Tab" -state normal
    }

    bind $scratchpadTab(text) <3> {focus %W; tk_popup $Scratchpad::menu %X %Y}
}

proc closeScratchpadTab {w} {
    set tab_current [$w index current]
    $w forget $tab_current
    destroy $tab_current
    if {[$w index end] <= 1} {
        $Scratchpad::menu entryconfigure "Close Tab" -state disabled
    }
}

proc showScratchpad {w} {
    if {$Scratchpad::show eq "false"} {
        wm withdraw $w
    } else {
        if [winfo exists $w] {
            wm deiconify $w
        } else {
            toplevel $w -class "Tedit"
            wm title $w "Scratchpad - tEdit"
            wm transient $w
            wm protocol $w WM_DELETE_WINDOW {.m.show invoke "Scratchpad"}

            ttk::notebook [set Scratchpad::notebook $w.notebook]
            createScratchpadMenu $Scratchpad::notebook
            newScratchpadTab $Scratchpad::notebook $Scratchpad::count
            pack $Scratchpad::notebook -fill both -expand true

            ttk::notebook::enableTraversal $Scratchpad::notebook

            bind $w <Control-t>  {$Scratchpad::menu invoke "New Tab"}
            bind $w <Control-F4> {$Scratchpad::menu invoke "Close Tab"}

            foreach keysym [list <F8> <Escape> <Control-q>] {
                bind $w $keysym {.m.show invoke "Scratchpad"}
            }

            # make Return and keypad Enter behave the same
            bind $w <KP_Enter> {event generate %W <Return>}
        }
    }
}


################################################################################
# TEDIT
#
namespace eval tEdit {
    variable show_browser   false
    variable show_menubar   .m
    variable show_statusbar true
    variable show_yscroll   true
    variable show_xscroll   true
    variable read_only      false
    variable word_wrap      none
    variable spacing        0
    variable tabstop        4
    variable blockcursor    false
    variable search         {}
    variable match_case     false
    variable reg_exp        -exact
    variable show_replace   false
    variable replace        {}
    variable show_search    false
    variable show_recent    false
    variable show_marks     false
    variable filename       {}
    variable savename       {}
    variable error_msg      {}
    variable show_mode      {}
    variable modified       {}
    variable position       {[1:1]}
    variable marks_id       0
    variable marks          [list]
    variable folds          [list]
    variable hsearch        [list]
    variable hreplace       [list]
    variable matches        0
    variable theme          [ttk::style theme use]
}

################################################################################
# PROCEDURES
#
proc cursorPosition {w args} {
    if {[lindex $args 0 1] in {insert delete mark}} {
        scan [$w index insert] %d.%d ypos xpos
        incr xpos
        set tEdit::position "\[$ypos:$xpos\]"
    }
}

proc setModified {w} {
    set tEdit::modified [expr {[$w edit modified] ? {[Modified]} : ""}]
}

proc clearModified {w} {
    $w edit reset
    $w edit modified 0
}

proc updateGUI {filename} {
    if {$filename eq "newfile"} {
        set tEdit::filename ""
        .m.help entryconfigure "File Details..." -state disabled
        wm title . "tEdit"
    } else {
        set tEdit::filename $filename
        .m.help entryconfigure "File Details..." -state normal
        wm title . "$filename - tEdit"
        recentAdd $filename
    }
}

proc errorMessage {msg} {
    set tEdit::error_msg $msg
    after 2000 {set tEdit::error_msg ""}
}

proc askSave {} {
    if {$tEdit::modified ne "" && $tEdit::read_only eq "false"} {
        set answer [tk_messageBox -title "Save file?" -icon warning \
            -type yesnocancel -default yes \
            -message "File has changed!" -detail "Save changes?"]
        switch -- $answer {
            "yes" {
                if {$tEdit::filename eq ""} {
                    if {[saveFileDialog] == 0} {
                        return [saveFile $tEdit::savename]
                    } else {
                        return 2
                    }
                } else {
                    return [saveFile $tEdit::filename]
                }
            }
            "no" {return 0}
            "cancel" {return 2}
        }
    }
    return 0
}

proc newFile {w} {
    if {[askSave] != 0} {return 2}
    if {$tEdit::read_only eq "true"} {.m.options invoke "Read Only"}
    $w delete 1.0 end
    updateGUI newfile
    markDelete $w "all"
    clearModified $w
}

proc openFileDialog {} {
    if {[askSave] != 0} {return 2}
    set filename [tk_getOpenFile -title "Open File"]
    if {$filename eq "" } {return 2}
    if {[file type $filename] ne "file"} {
        tk_messageBox -title "Cannot open file!" -icon error -type ok \
            -message "Cannot open file:" \
            -detail "$filename\nis a [file type $filename]."
        return 1
    } else {
        openFile $filename
    }
}

proc openFile {filename} {
    if [catch {set fh [open $filename r]} msg] {
        errorMessage [lindex [split $msg :] 1]
        return 1
    }
    if {$tEdit::read_only eq "true"} {.m.options invoke "Read Only"}
    .text replace 1.0 end [read -nonewline $fh]
    close $fh
    .text mark set insert 1.0
    .text see insert
    if {[file writable $filename] == 0} {
        .m.options invoke "Read Only"
    }
    updateGUI $filename
    markDelete .text "all"
    clearModified .text
}

proc saveFileDialog {} {
    set filename [tk_getSaveFile -title "Save As"]
    if {$filename eq "" } {return 2}
    if {[file exists $filename]} {
        if {[file type $filename] ne "file"} {
            tk_messageBox -title "Cannot save file!" -icon error -type ok \
                -message "Cannot save [file tail $filename]:" \
                -detail "$filename\nis a [file type $filename]."
            return 1
        } elseif {[file writable $filename] == 0} {
            tk_messageBox -title "Cannot save file!" -icon error -type ok \
                -message "Cannot save [file tail $filename]:" \
                -detail "$filename\nis read only."
            return 1
        } else {
            set tEdit::savename $filename
            return 0
        }
    } else {
        set tEdit::savename $filename
        return 0
    }
}

proc saveFile {filename} {
    if {$filename eq ""} {
        if {[saveFileDialog] == 0} {
            set filename $tEdit::savename
        } else {
            return 2
        }
    }
    if [catch {set fh [open $filename w]} msg] {
        errorMessage [lindex [split $msg :] 1]
        return 1
    }
    puts -nonewline $fh [.text get 1.0 end]
    close $fh
    updateGUI $filename
    clearModified .text
    return 0
}

proc saveAs {} {
    if {[saveFileDialog] == 0} {saveFile $tEdit::filename}
}

proc exitCommand {} {
    if {[askSave] == 0} {exit 0}
}

proc recentAdd {filename} {
    set recent [.l_recent get 0 end]
    if {$filename ni $recent} {
        .l_recent insert 0 $filename
        .m.file entryconfigure "Recent Files..." -state normal
        if {[llength $recent] == 5} {
            grid .ysb_recent
        }
    }
}

proc recentOpen {w} {
    if {[askSave] != 0} {return 2}
    set filename [$w get active]
    openFile $filename
}

proc undoRedo {w command} {
    if [catch {$w edit $command} msg] {
        errorMessage $msg
    }
}

proc selectAll {w} {
    $w tag add sel 1.0 end
}

proc foldLines {w tag} {
    lassign [$w tag ranges $tag] from to
    if {$from eq ""} {
        errorMessage "select lines to fold"
        return 1
    }
    scan $from %d from_line
    scan $to %d to_line
    # check if a fold exists in current selection
    foreach old_fold $tEdit::folds {
        lassign [$w tag ranges $old_fold] old_from old_to
        scan $old_from %d old_from_line
        scan $old_to %d old_to_line

        if {$from_line <= $old_from_line && $to_line >= $old_to_line} {
            $old_fold invoke
        }
    }
    # get first line text to show in fold button
    set fold_lines [$w count -lines $from $to+1line]
    set fold_line [$w get $from_line.0 $from_line.end]
    set fold_text "\u25b6\u25b6 $fold_lines lines: $fold_line"
    set fold "$w.$from_line-$to_line"
    button $fold -text "$fold_text" -padx 0 -pady 0 -relief flat \
        -takefocus 0 -cursor "left_ptr" -command [list unFoldLines $w $fold]
    $w tag configure $fold -elide "true"
    $w tag add $fold $from_line.0 $to_line.end
    $w window create $from_line.0 -window $fold
    $w mark set insert $to_line.0+1line
    $w tag remove $tag $from $to
    lappend tEdit::folds $fold
    .m.edit entryconfigure "Unfold All" -state normal
}

proc unFoldLines {w which} {
    switch -- $which {
        ""  {return 2}
        "all" {
            foreach fold $tEdit::folds {
                $w tag configure $fold -elide "false"
                destroy $fold
            }
            set tEdit::folds [list]
        }
        default {
            $w tag configure $which -elide "false"
            destroy $which
            set tEdit::folds [lsearch -inline -all -not -exact $tEdit::folds $which]
        }
    }
    if {[llength $tEdit::folds] == 0} {
        .m.edit entryconfigure "Unfold All" -state disabled
    }
}

proc searchText {w what {direction -forwards}} {
    if {$what eq ""} {
        errorMessage "nothing to search for"
        return 1
    }
    if {$what ni $tEdit::hsearch} {
        lappend tEdit::hsearch $what
    }
    clearHighlight $w tag_search
    set command [list $w search $tEdit::reg_exp $direction -count n -- $what]
    if {$direction eq "-backwards"} {
        set command [linsert $command end {insert-1char}]
    } else {
        set command [linsert $command end {insert+1char}]
    }
    if {$tEdit::match_case eq "false"} {
        set command [linsert $command 2 -nocase]
    }
    if [catch {set position [{*}$command]} msg] {
        .cb_search configure -style red.TCombobox
        errorMessage [lindex [split $msg :] 1]
        return 1
    }
    if {$position eq ""} {
        .cb_search configure -style red.TCombobox
        return 1
    }
    $w tag add tag_search $position $position+${n}c
    $w mark set insert $position
    $w see $position
}

proc searchAll {w what} {
    if {$what eq ""} {
        errorMessage "nothing to search for"
        return 1
    }
    set tEdit::matches 0
    set command [list $w search $tEdit::reg_exp -all -count n -- $what 1.0 end]
    if {$tEdit::match_case eq "false"} {
        set command [linsert $command 2 -nocase]
    }
    if [catch {set positions [{*}$command]} msg] {
        .cb_search configure -style red.TCombobox
        errorMessage [lindex [split $msg :] 1]
        return 1
    }
    if {$positions eq ""} {return 1}
    set i 0
    foreach position $positions {
        $w tag add tag_search_all $position $position+[lindex $n $i]c
        incr i
    }
    set tEdit::matches [llength $n]
}

proc replaceText {w what with} {
    if {$with ni $tEdit:::hreplace} {
        lappend tEdit::hreplace $with
    }
    if {[$w tag ranges tag_search] eq ""} {
        searchText $w $what
    }
    if {[$w tag ranges tag_search] ne ""} {
        $w replace {*}[$w tag ranges tag_search] $with
        searchText $w $what
    } else {
        errorMessage "nothing to replace"
        return 1
    }
}

proc replaceAll {w what with} {
    searchAll $w $what
    while {$tEdit::matches > 0} {
        replaceText $w $what $with
        incr tEdit::matches -1
    }
}

proc clearHighlight {w tags} {
    foreach tag $tags {
        foreach {from to} [$w tag ranges $tag] {
            $w tag remove $tag $from $to
        }
    }
}

proc markLine {w} {
    set linenum [lindex [split [$w index insert] .] 0]
    set mark [lsearch -inline -all -glob [$w tag names $linenum.0] "Mark*"]
    if {$mark eq ""} {
        if {[$w index $linenum.0] eq [$w index $linenum.end]} {
            errorMessage "cannot mark: empty line"
            return 1
        }
        set mark "Mark[incr tEdit::marks_id]"
        $w mark set $mark $linenum.0
        $w tag configure $mark -underline true
        $w tag raise $mark sel
        $w tag add $mark "$linenum.0" "$linenum.end"
        lappend tEdit::marks $mark
        .m.marks entryconfigure "Next Mark" -state normal
        .m.marks entryconfigure "Clear All Marks" -state normal
    } else {
        markDelete $w $mark
    }
}

proc markSee {w} {
    set mark [.l_marks get active]
    if {$mark eq ""} {
        errorMessage "select a mark"
        return 1
    }
    $w mark set insert $mark
    $w see $mark
}

proc markNext {w} {
    if {[llength $tEdit::marks] == 0} {
        errorMessage "no marks found"
        return 1
    }
    set mark [$w mark next insert+1char]
    while {$mark ni $tEdit::marks} {
        if {$mark eq ""} {set mark 1.0}
        set mark [$w mark next $mark]
    }
    set index [lsearch $tEdit::marks $mark]
    .l_marks selection clear 0 end
    .l_marks selection set $index
    .l_marks activate $index
    $w mark set insert $mark
    $w see $mark
}

proc markDelete {w which} {
    switch -- $which {
        "all" {
            foreach mark $tEdit::marks {
                $w mark unset $mark
                $w tag delete $mark
            }
            set tEdit::marks [list]
        }
        "active" {
            set mark [.l_marks get active]
            $w mark unset $mark
            $w tag delete $mark
            .l_marks delete active
        }
        default {
            $w mark unset $which
            $w tag delete $which
            .l_marks delete [lsearch $tEdit::marks $which]
        }
    }
    if {[llength $tEdit::marks] == 0} {
        .m.marks entryconfigure "Next Mark" -state disabled
        .m.marks entryconfigure "Clear All Marks" -state disabled
    }
}

proc populateBrowser {w node} {
    set path [$w set $node fullpath]
    $w delete [$w children $node]
    if [catch {glob -nocomplain -dir $path *} msg] {
        errorMessage [lindex [split $msg :] 1]
        return 1
    }
    foreach f [lsort -dictionary [glob -nocomplain -dir $path *]] {
        set type [file type $f]
        set id [$w insert $node end -text [file tail $f] -values [list $f $type]]
        if {$type eq "directory"} {
            $w insert $id 0
            $w item $id -text [file tail $f]/
        }
    }
}

proc startBrowser {w} {
    foreach dir [lsort -dictionary [file volumes]] {
        populateBrowser $w [$w insert {} end -text $dir -values [list $dir directory]]
    }
}

proc openfileBrowser {w node} {
    if {[$w set $node type] eq "file"} {
        set path [$w set $node fullpath]
        openFile $path
    } else {
        populateBrowser $w $node
    }
}

proc toggleBrowser {w} {
    if {$tEdit::show_browser eq "true"} {
        .pane insert 0 $w
    } else {
        .pane forget $w
    }
}

proc toggleView {w show} {
    if {$show eq "false"} {
        grid remove $w
        focus .text
    } else {
        grid $w
        switch -- $w {
            .lf_recent  {focus .l_recent}
            .f_search   {focus .cb_search}
            .lf_replace {focus .cb_replace}
        }
    }
}

proc toggleSafeMode {} {
    set tEdit::show_mode [expr {$tEdit::read_only eq "true" ? {[Safe Mode]} : ""}]
    set state [expr {$tEdit::read_only eq "true" ? "disabled" : "normal"}]
    if {$tEdit::read_only eq "true" && $tEdit::show_replace eq "true"} {
        .ck_replace invoke
    }
    foreach widget [list .text .ck_replace ] {
        $widget configure -state $state
    }
    .m.file entryconfigure "Save" -state $state
    foreach menu_entry [list "Undo" "Redo" "Cut" "Paste"] {
        .m.edit entryconfigure $menu_entry -state $state
    }
}

proc setSpacing {w spacing} {
    $w configure -spacing1 $spacing
}

proc setTabstop {w tabstop} {
    $w configure -tabs "[expr {$tabstop * [font measure [$w cget -font] 0]}] left"
}

proc tabsToSpaces {w tabstop} {
    set answer [tk_messageBox -title "Convert Tabs into Spaces?" \
        -icon warning -type yesno -default no \
        -message "This will convert all Tab characters into $tabstop Spaces!" \
        -detail "It cannot be undone. Are you sure you want to continue?"]
    if {$answer eq "no"} {return 0}
    set tabstop [string repeat " " $tabstop]
    set text_tabs [$w get 1.0 end]
    regsub -all {\t} $text_tabs $tabstop text_spaces
    $w replace 1.0 end $text_spaces
}

proc selectFont {w font} {
    $w configure -font [font actual $font]
}

proc setFont {w tabstop} {
    tk fontchooser configure -title "Set Font" -parent . \
        -font [$w cget -font] -command [list selectFont $w]
    tk fontchooser show
    $w configure -tabs "[expr {$tabstop * [font measure [$w cget -font] 0]}] left"
}

proc setColor {w which} {
    switch -- $which {
        "cursor" {
            set color [tk_chooseColor -title "Set $which color" \
                -initialcolor [$w cget -insertbackground]]
            if {$color eq ""} {return 2}
            $w configure -insertbackground $color
        }
        "search" {
            set color [tk_chooseColor -title "Set $which color" \
                -initialcolor [$w tag cget tag_search_all -background]]
            if {$color eq ""} {return 2}
            $w tag configure tag_search \
                -foreground $color -background [$w cget -foreground]
            $w tag configure tag_search_all \
                -foreground [$w cget -foreground] -background $color
        }
        default {
            set color [tk_chooseColor -title "Set $which color" \
                -initialcolor [$w cget -$which]]
            if {$color eq ""} {return 2}
            foreach widget [list $w .l_recent .l_marks] {
                $widget configure -$which $color
                $widget configure -selectbackground [$widget cget -foreground]
                $widget configure -selectforeground [$widget cget -background]
            }
            $w tag configure tag_search     -background [$w cget -foreground]
            $w tag configure tag_search_all -foreground [$w cget -foreground]
        }
    }
}

proc fileDetails {file} {
    if [catch {tk_messageBox \
        -title "File Details" -icon info -type ok \
        -message "[file tail $file]" \
        -detail "\
            Size:\t[file size $file]\n\
            Lines:\t[.text count -lines 1.0 end]\n\
            Writable:\t[expr {[file writable $file] ? "Yes" : "No"}]"
        }] {return 1}
}

proc systemDetails {} {
    if [catch {tk_messageBox \
        -title "System Details" -icon info -type ok \
        -message "Tcl/Tk Version: [info patchlevel]" \
        -detail "\
            User Name:\t$::tcl_platform(user)\n\
            Hostname:\t[info hostname]\n\
            OS Family:\t$::tcl_platform(platform)\n\
            OS Identifier:\t$::tcl_platform(os)\n\
            OS Version:\t$::tcl_platform(osVersion)\n\
            Architecture:\t$::tcl_platform(machine)\n\
            Window System:\t[tk windowingsystem]"
        }] {return 1}
}

proc helpAbout {} {
    tk_messageBox \
        -title "About tEdit" -icon info -type ok \
        -message "tEdit" -detail \
{A simple text editor,
written in pure Tcl/Tk.

The MIT License

Copyright (c) Thanos Zygouris
<athanasios.zygouris@gmail.com>}
}

################################################################################
# TTK STYLES
#
ttk::style configure white.TCombobox    -fieldbackground white
ttk::style configure red.TCombobox      -fieldbackground red

################################################################################
# MENUS
#
proc createMenus {} {
    menu .m -tearoff 0
        menu .m.file -tearoff 0
        .m add cascade -label "File" -underline 0 -menu .m.file
            .m.file add command -label "New" -underline 0 \
                -command {newFile .text}
            .m.file add command -label "Open..." -underline 0 \
                -accelerator "Control+O" -command {openFileDialog}
            .m.file add command -label "Save" -underline 0 \
                -accelerator "Control+S" -command {saveFile $tEdit::filename}
            .m.file add command -label "Save As..." -underline 5 \
                -accelerator "Control+Shift+S" -command {saveAs}
            .m.file add separator
            .m.file add checkbutton -label "Recent Files..." -underline 0 \
                -accelerator "F6" -state "disabled" \
                -variable tEdit::show_recent -onvalue "true" -offvalue "false" \
                -command {toggleView .lf_recent $tEdit::show_recent}
            .m.file add separator
            .m.file add command -label "Exit" -underline 1 \
                -accelerator "Control+Q" -command {exitCommand}
        menu .m.edit -tearoff 0
        .m add cascade -label "Edit" -underline 0 -menu .m.edit
            .m.edit add command -label "Undo" -underline 0 \
                -accelerator "Control+Z" -command {undoRedo .text undo}
            .m.edit add command -label "Redo" -underline 0 \
                -accelerator "Control+Shift+Z" -command {undoRedo .text redo}
            .m.edit add separator
            .m.edit add command -label "Cut" -underline 2 \
                -accelerator "Control+X" -command {tk_textCut .text}
            .m.edit add command -label "Copy" -underline 0 \
                -accelerator "Control+C" -command {tk_textCopy .text}
            .m.edit add command -label "Paste" -underline 0 \
                -accelerator "Control+V" -command {tk_textPaste .text}
            .m.edit add separator
            .m.edit add command -label "Select All" -underline 7 \
                -accelerator "Control+A" -command {selectAll .text}
            .m.edit add separator
            .m.edit add command -label "Fold Lines" -underline 0 \
                -accelerator "Control+J" -command {foldLines .text sel}
            .m.edit add command -label "Unfold All" -underline 1 \
                -accelerator "Control+Shift+J" -state disabled \
                -command {unFoldLines .text all}
        menu .m.search -tearoff 0
        .m add cascade -label "Search" -underline 0 -menu .m.search
            .m.search add checkbutton -label "Search..." -underline 0 \
                -accelerator "Control+F" \
                -variable tEdit::show_search -onvalue "true" -offvalue "false" \
                -command {toggleView .f_search $tEdit::show_search}
            .m.search add command -label "Find Next" -underline 5 \
                -accelerator "F3" -command {.b_findnext invoke}
            .m.search add command -label "Find Prev" -underline 5 \
                -accelerator "Shift+F3" -command {.b_findprev invoke}
            .m.search add command -label "Clear Highlight" -underline 0 \
                -accelerator "Control+L" \
                -command {clearHighlight .text [list tag_search tag_search_all]}
        menu .m.marks -tearoff 0
        .m add cascade -label "Marks" -underline 0 -menu .m.marks
            .m.marks add checkbutton -label "Show Marks..." -underline 0 \
                -accelerator "Shift+F5" \
                -variable tEdit::show_marks -onvalue "true" -offvalue "false" \
                -command {toggleView .lf_marks $tEdit::show_marks}
            .m.marks add command -label "Mark/Unmark" -underline 0 \
                -accelerator "Control+M" -command [list markLine .text]
            .m.marks add command -label "Next Mark" -underline 0 \
                -accelerator "F5" -state disabled \
                -command [list markNext .text]
            .m.marks add command -label "Clear All Marks" -underline 0 \
                -accelerator "Control+Shift+M" -state disabled \
                -command [list markDelete .text "all"]
        menu .m.show -tearoff 0
        .m add cascade -label "Show" -underline 3 -menu .m.show
            .m.show add checkbutton -label "File Browser" -underline 0 \
                -accelerator "F2" \
                -variable tEdit::show_browser -onvalue "true" -offvalue "false" \
                -command {toggleBrowser .tree}
            .m.show add separator
            .m.show add checkbutton -label "Menu Bar" -underline 0 \
                -variable tEdit::show_menubar -onvalue ".m" -offvalue "" \
                -command {. configure -menu $tEdit::show_menubar}
            .m.show add checkbutton -label "Status Bar" -underline 7 \
                -variable tEdit::show_statusbar -onvalue "true" -offvalue "false" \
                -command {toggleView .f_statusbar $tEdit::show_statusbar}
            .m.show add checkbutton -label "Vertical Scrollbar" -underline 0 \
                -variable tEdit::show_yscroll -onvalue "true" -offvalue "false" \
                -command {toggleView .ysb_text $tEdit::show_yscroll}
            .m.show add checkbutton -label "Horizontal Scrollbar" -underline 0 \
                -variable tEdit::show_xscroll -onvalue "true" -offvalue "false" \
                -command {toggleView .xsb_text $tEdit::show_xscroll}
            .m.show add separator
            .m.show add checkbutton -label "Scratchpad" -underline 0 \
                -accelerator "F8" \
                -variable Scratchpad::show -onvalue "true" -offvalue "false" \
                -command {showScratchpad .scratchpad}
        menu .m.options -tearoff 0
        .m add cascade -label "Options" -underline 0 -menu .m.options
            .m.options add checkbutton -label "Read Only" -underline 0 \
                -accelerator "Control+R" \
                -variable tEdit::read_only -onvalue "true" -offvalue "false" \
                -command {toggleSafeMode}
            .m.options add checkbutton -label "Word Wrap" -underline 5 \
                -accelerator "Control+W" \
                -variable tEdit::word_wrap -onvalue "word" -offvalue "none" \
                -command {.text configure -wrap $tEdit::word_wrap}
            .m.options add separator
            .m.options add checkbutton -label "Block Cursor" -underline 0 \
                -variable tEdit::blockcursor -onvalue "true" -offvalue "false" \
                -command {.text configure -blockcursor $tEdit::blockcursor}
            .m.options add separator
            .m.options add command -label "Set Font..." -underline 4 \
                -command {setFont .text $tEdit::tabstop}
            menu .m.options.spacing -tearoff 0
            .m.options add cascade -label "Line Spacing" -underline 0 -menu .m.options.spacing
                for {set i 0} {$i <= 5} {incr i} {
                    .m.options.spacing add radiobutton -label $i -underline 0 \
                        -variable tEdit::spacing -value $i \
                        -command {setSpacing .text $tEdit::spacing}
                }
            .m.options add separator
            menu .m.options.themes -tearoff 0
            .m.options add cascade -label "Themes" -underline 0 -menu .m.options.themes
                foreach theme [ttk::style theme names] {
                    .m.options.themes add radiobutton -label $theme \
                        -variable tEdit::theme -value $theme \
                        -command [list ttk::style theme use $theme]
                }
            .m.options add separator
            menu .m.options.colors -tearoff 0
            .m.options add cascade -label "Colors" -underline 0 -menu .m.options.colors
                .m.options.colors add command -label "Cursor Color..." -underline 0 \
                    -command {setColor .text "cursor"}
                .m.options.colors add command -label "Search Color..." -underline 0 \
                    -command {setColor .text "search"}
                .m.options.colors add command -label "Foreground Color..." -underline 0 \
                    -command {setColor .text "foreground"}
                .m.options.colors add command -label "Background Color..." -underline 0 \
                    -command {setColor .text "background"}
            .m.options add separator
            menu .m.options.tabstop -tearoff 0
            .m.options add cascade -label "Tab Stops" -underline 0 -menu .m.options.tabstop
                foreach i [list 2 3 4 6 8] {
                    .m.options.tabstop add radiobutton -label $i -underline 0 \
                        -variable tEdit::tabstop -value $i \
                        -command {setTabstop .text $tEdit::tabstop}
                }
            .m.options add command -label "Tabs to Spaces" -underline 8 \
                -command {tabsToSpaces .text $tEdit::tabstop}
        menu .m.help -tearoff 0
        .m add cascade -label "Help" -underline 0 -menu .m.help
            .m.help add command -label "File Details..." -underline 0 \
                -command {fileDetails $tEdit::filename} -state disabled
            .m.help add command -label "System Details..." -underline 0 \
                -command {systemDetails}
            .m.help add separator
            .m.help add command -label "About tEdit..." -underline 0 \
                -accelerator "F1" -command {helpAbout}
    . configure -menu .m

    menu .find_popup -tearoff 0
        .find_popup add command -label "Cut" \
            -underline 2 -accelerator "Control+X" \
            -command {event generate [focus] <<Cut>>}
        .find_popup add command -label "Copy" \
            -underline 0 -accelerator "Control+C" \
            -command {event generate [focus] <<Copy>>}
        .find_popup add command -label "Paste" \
            -underline 0 -accelerator "Control+V" \
            -command {event generate [focus] <<Paste>>}
}

################################################################################
# WIDGETS
#
proc createWidgets {} {

    ttk::labelframe .lf_recent -borderwidth 1 -relief flat \
        -text "Recently Opened Files:"
        tk::listbox .l_recent -relief flat -height 5 -highlightthickness 0 \
            -takefocus 0 -yscrollcommand {.ysb_recent set}
        ttk::scrollbar .ysb_recent -orient vertical -command {.l_recent yview}
        # grid recent file list and scrollbar in the labelframe
        grid .l_recent      -in .lf_recent -row 0 -column 0 -sticky we
        grid .ysb_recent    -in .lf_recent -row 0 -column 1 -sticky ns
        grid columnconfigure .lf_recent .l_recent -weight 1
        # remove scrollbar from view
        grid remove .ysb_recent

    # create a paned window
    ttk::panedwindow .pane -orient horizontal
    # frame for the left pane
    ttk::frame .left_pane
        ttk::treeview .tree -selectmode browse \
            -columns {fullpath type} -displaycolumns {} \
            -yscroll {.ysb_tree set}
        .tree heading {#0} -anchor c -text "File Browser"
        ttk::scrollbar .ysb_tree -orient vertical -command {.tree yview}
        # grid treeview and its scrollbars in the left pane frame
        grid .tree      -in .left_pane -row 0 -column 0 -sticky news
        grid .ysb_tree  -in .left_pane -row 0 -column 1 -sticky ns
        grid rowconfigure       .left_pane  .tree -weight 1
        grid columnconfigure    .left_pane .tree -weight 1
    # frame for the right pane
    ttk::frame .right_pane
        ttk::labelframe .lf_marks -borderwidth 1 -relief flat -text "Marks:"
        tk::listbox .l_marks -listvariable tEdit::marks -width 10 \
            -takefocus 0 -highlightthickness 0
        # grid listbox in its labelfame
        grid .l_marks   -in .lf_marks   -row 0 -column 0 -sticky ns
        grid rowconfigure .lf_marks .l_marks -weight 1

        tk::text .text -setgrid false -relief flat -highlightthickness 0 -takefocus 0 \
            -xscrollcommand {.xsb_text set} \
            -yscrollcommand {.ysb_text set} \
            -wrap $tEdit::word_wrap -undo true -autoseparators true \
            -tabstyle wordprocessor \
            -blockcursor false -insertunfocussed hollow
        # search tags management and basic colors
        .text tag configure tag_search     -background black  -foreground yellow
        .text tag configure tag_search_all -background yellow -foreground black
        .text tag raise tag_search
        .text tag lower tag_search_all tag_search

        ttk::scrollbar .xsb_text -orient horizontal -command {.text xview}
        ttk::scrollbar .ysb_text -orient vertical -command {.text yview}

        ttk::frame .f_search -borderwidth 1 -relief sunken
            ttk::labelframe .lf_search -borderwidth 1 -relief flat -text "Search for:"
                ttk::combobox .cb_search -style white.TCombobox \
                    -textvariable tEdit::search -values $tEdit::hsearch \
                    -postcommand {.cb_search configure -values $tEdit::hsearch}
                ttk::button .b_findnext -text "Find Next" -width 9 \
                    -underline 5 -takefocus 0 \
                    -command {
                        searchAll .text $tEdit::search
                        searchText .text $tEdit::search
                    }
                ttk::button .b_findprev -text "Find Prev" -width 9 \
                    -underline 5 -takefocus 0 \
                    -command {
                        searchAll .text $tEdit::search
                        searchText .text $tEdit::search -backwards
                    }
                ttk::checkbutton .ck_matchcase -text "Match Case" \
                    -underline 0 -takefocus 0 \
                    -variable tEdit::match_case -onvalue "true" -offvalue "false"
                ttk::checkbutton .ck_regexp -text "Regular Expression" \
                    -underline 8 -takefocus 0 \
                    -variable tEdit::reg_exp -onvalue "-regexp" -offvalue "-exact"
                ttk::checkbutton .ck_replace -text "Replace" \
                    -underline 0 -takefocus 0 \
                    -variable tEdit::show_replace -onvalue "true" -offvalue "false" \
                    -command {toggleView .lf_replace $tEdit::show_replace}
                # grid them all in the search labelframe
                grid .cb_search     -in .lf_search -row 0 -column 0
                grid .b_findnext    -in .lf_search -row 0 -column 1
                grid .b_findprev    -in .lf_search -row 0 -column 2
                grid .ck_matchcase  -in .lf_search -row 0 -column 3
                grid .ck_regexp     -in .lf_search -row 0 -column 4
                grid .ck_replace    -in .lf_search -row 0 -column 5 -sticky e
                grid columnconfigure .lf_search .ck_replace -weight 1

            ttk::labelframe .lf_replace -borderwidth 1 -relief flat -text "Replace with:"
                ttk::combobox .cb_replace -style white.TCombobox \
                    -textvariable tEdit::replace -values $tEdit::hreplace \
                    -postcommand {.cb_replace configure -values $tEdit::hreplace}
                ttk::button .b_replace -text "Replace" -width 9 \
                    -underline 0 -takefocus 0 \
                    -command {replaceText .text $tEdit::search $tEdit::replace}
                ttk::button .b_replaceall -text "All" -width 9 \
                    -underline 0 -takefocus 0 \
                    -command {replaceAll .text $tEdit::search $tEdit::replace}
                # grid them all in the replace labelframe
                grid .cb_replace    -in .lf_replace -row 0 -column 0
                grid .b_replace     -in .lf_replace -row 0 -column 1
                grid .b_replaceall  -in .lf_replace -row 0 -column 2
            # grid find and replace labelframes in the search frame
            grid .lf_search     -in .f_search -row 0 -column 0 -sticky we
            grid .lf_replace    -in .f_search -row 1 -column 0 -sticky we
            grid columnconfigure .f_search .lf_search -weight 1
            # remove replace frame from view
            grid remove .lf_replace
        # grid  text, its scrollbars, mark list and search frame in the right pane frame
        grid .text      -in .right_pane -row 0 -column 0 -sticky news
        grid .ysb_text  -in .right_pane -row 0 -column 1 -sticky ns
        grid .lf_marks  -in .right_pane -row 0 -column 2 -sticky ns
        grid .xsb_text  -in .right_pane -row 1 -column 0 -sticky we -columnspan 1
        grid .f_search  -in .right_pane -row 2 -column 0 -sticky we -columnspan 3
        grid rowconfigure       .right_pane .text -weight 1
        grid columnconfigure    .right_pane .text -weight 1
        # remove mark list from view
        grid remove .lf_marks

    ttk::frame .f_statusbar -borderwidth 1 -relief sunken
        ttk::label .lb_filename -relief flat -anchor e  -textvariable tEdit::filename
        ttk::label .lb_message  -relief flat -anchor c  -textvariable tEdit::error_msg
        ttk::label .lb_safemode -relief flat -anchor w  -textvariable tEdit::show_mode
        ttk::label .lb_modified -relief flat -anchor w  -textvariable tEdit::modified
        ttk::label .lb_position -relief flat -anchor w  -textvariable tEdit::position
        ttk::sizegrip .lb_sizegrip
        # grid all statusbar labels in the statusbar frame
        grid .lb_filename -in .f_statusbar -row 0 -column 0 -sticky w
        grid .lb_message  -in .f_statusbar -row 0 -column 1 -sticky we
        grid .lb_safemode -in .f_statusbar -row 0 -column 2
        grid .lb_modified -in .f_statusbar -row 0 -column 3
        grid .lb_position -in .f_statusbar -row 0 -column 4
        grid .lb_sizegrip -in .f_statusbar -row 0 -column 5 -sticky e
        grid columnconfigure .f_statusbar .lb_message -weight 1

    # grid the three main frames in main window
    grid .lf_recent     -in . -row 0 -column 0 -sticky news
    grid .pane          -in . -row 1 -column 0 -sticky news
    grid .f_statusbar   -in . -row 2 -column 0 -sticky we
    grid rowconfigure       . .pane -weight 1
    grid columnconfigure    . .pane -weight 1
    # remove recent list and rearch frame from view
    grid remove .lf_recent .f_search

    # add left and right panes to paned window
    .pane add .left_pane
    .pane add .right_pane
    # remove left pane from view
    .pane forget .left_pane
}

################################################################################
# BINDINGS
#
proc createBindings {} {
    # deactivate some predefined bindings from Text widget
    set bindings [list \
        <Control-a> \
        <Control-f> \
        <Control-o> \
        <Control-t> \
        <Control-z> \
        <Control-Shift-Z>\
    ]
    foreach key $bindings {
        bind Text $key {return}
    }

    # main window bindings
    bind . <<TkFontchooserVisibility>> {
        if {[tk fontchooser configure -visible]} {
            .m.options entryconfigure "Set Font..." -state disabled
        } else {
            .m.options entryconfigure "Set Font..." -state normal
        }
    }
    bind . <Control-o>       {.m.file    invoke "Open..."}
    bind . <Control-s>       {.m.file    invoke "Save"}
    bind . <Control-Shift-S> {.m.file    invoke "Save As..."}
    bind . <F6>              {.m.file    invoke "Recent Files..."}
    bind . <Control-q>       {.m.file    invoke "Exit"}
    bind . <Control-Shift-Q> {exit}
    bind . <Control-z>       {.m.edit    invoke "Undo"}
    bind . <Control-Shift-Z> {.m.edit    invoke "Redo"}
    bind . <Control-a>       {.m.edit    invoke "Select All"}
    bind . <Control-j>       {.m.edit    invoke "Fold Lines"}
    bind . <Control-J>       {.m.edit    invoke "Unfold All"}
    bind . <Control-f>       {.m.search  invoke "Search..."}
    bind . <F3>              {.m.search  invoke "Find Next"}
    bind . <Shift-F3>        {.m.search  invoke "Find Prev"}
    bind . <Control-l>       {.m.search  invoke "Clear Highlight"}
    bind . <Shift-F5>        {.m.marks   invoke "Show Marks..."}
    bind . <Control-m>       {.m.marks   invoke "Mark/Unmark"}
    bind . <F5>              {.m.marks   invoke "Next Mark"}
    bind . <Control-M>       {.m.marks   invoke "Clear All Marks"}
    bind . <F2>              {.m.show    invoke "File Browser"}
    bind . <F8>              {.m.show    invoke "Scratchpad"}
    bind . <Control-r>       {.m.options invoke "Read Only"}
    bind . <Control-w>       {.m.options invoke "Word Wrap"}
    bind . <F1>              {.m.help    invoke "About tEdit..."}
    # make Return and keypad Enter behave the same
    bind . <KP_Enter> {event generate %W <Return>}

    # treeview widget bindings
    foreach keysym [list <Return> <Double-ButtonRelease-1>] {
        bind .tree $keysym {openfileBrowser %W [%W focus]}
    }
    bind .tree  <<TreeviewOpen>> {populateBrowser %W [%W focus]}

    # text widget bindings
    bind .text  <<Modified>>              {setModified %W}
    bind .text  <Control-ButtonRelease-1> {.m.marks invoke "Mark/Unmark"}
    bind .text  <3>                       {focus %W; tk_popup .m.edit %X %Y}
    bind .text  <Control-3>               {focus %W; tk_popup .m %X %Y}

    # recent file list bindings
    foreach keysym [list <Return> <Double-ButtonRelease-1>] {
        bind .l_recent $keysym {recentOpen %W}
    }

    # mark list bindings
    foreach keysym [list <Return> <Double-ButtonRelease-1>] {
        bind .l_marks $keysym {markSee .text}
    }
    bind .l_marks <Delete> {markDelete .text active}

    # search & replace bindings
    foreach combobox [list .cb_search .cb_replace] {
        bind $combobox <3>      {focus %W; tk_popup .find_popup %X %Y}
        bind $combobox <Escape> {.m.search invoke "Search..."}
    }
    foreach keysym [list <<ComboboxSelected>> <KeyPress>] {
        bind .cb_search $keysym {
            .m.search invoke "Clear Highlight"
            .cb_search configure -style white.TCombobox
        }
    }
    bind .cb_search  <Return> {.b_findnext invoke}
    bind .cb_replace <Return> {.b_replace invoke}
}

################################################################################
# MAIN PROGRAM
#
createMenus
createWidgets
createBindings
startBrowser .tree
setTabstop .text $tEdit::tabstop
focus .text

wm title    . "tEdit"
wm minsize  . 750 450
wm protocol . WM_DELETE_WINDOW {.m.file invoke "Exit"}

trace add execution .text leave [list cursorPosition .text]

################################################################################
# COMMAND LINE
#
if {$::argc > 0} {
    set tEdit::filename [lindex $::argv end]
    if [file exists $tEdit::filename] {
        if {[file type $tEdit::filename] ne "file"} {
            puts stderr "error: $tEdit::filename is a [file type $tEdit::filename]"
            exit 1
        } else {
            openFile $tEdit::filename
        }
    }
}
